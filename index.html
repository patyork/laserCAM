<!DOCTYPE html>
<html lang="en">
<head>
    <title>three.js webgl - trackball controls</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            color: #000;
            font-family:Monospace;
            font-size:13px;
            text-align:center;
            font-weight: bold;

            background-color: #fff;
            margin: 0px;
            overflow: hidden;
        }

        #info {
            color:#000;
            position: absolute;
            top: 0px; width: 100%;
            padding: 5px;

        }

        a {
            color: red;
        }
    </style>
</head>

<body>
<div id="container"></div>
<div id="info">
    Mouse + Left: Rotate | Scroll Wheel: Zoom | Mouse + Right: Pan | Keyboard "R": Reset View<br />
    Change Texture: <input id="userImage" type="file" onchange="streamFileToBuffer()" />
</div>

<script src="lib/three.js"></script>
<script src="lib/controls/TrackballControls.js"></script>
<script src="lib/Detector.js"></script>
<script src="lib/stats.min.js"></script>

<script>

    if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

    var container, stats;

    var camera, controls, scene, renderer;
    var removable_items = [];

    var cross;

    init();
    animate();

    function streamFileToBuffer(){
        var uploadedImage = document.createElement( 'img' );
        var file    = document.querySelector('input[type=file]').files[0]; //sames as here
        var reader  = new FileReader();

        reader.onloadend = function () {
            uploadedImage.src = reader.result;

            var texture = new THREE.Texture(uploadedImage);
            texture.needsUpdate = true;
            texture.minFilter = THREE.LinearFilter;

            var material = new THREE.MeshLambertMaterial({map: texture});
            var geometry = new THREE.BoxGeometry( texture.image.width/10.0, texture.image.height/10.0,0 );

            // Reverse back face - make it appear as a 2D iamge floating in 3D space
            geometry.faceVertexUvs[0][2] =  [new THREE.Vector2(1,1), new THREE.Vector2(1, 0), new THREE.Vector2(0, 1)];
            geometry.faceVertexUvs[0][3] =  [new THREE.Vector2(1,0), new THREE.Vector2(0, 0), new THREE.Vector2(0, 1)];

            var cube = new THREE.Mesh( geometry, material );

            cube.position.z = 0.1; // run up a bit, so the axes don't interfere with the display of the rectangle
            scene.remove(removable_items.pop());

            removable_items.push(cube);
            scene.add( cube );
            render();

        };

        if (file) {
            reader.readAsDataURL(file); //reads the data as a URL
        } else {
            uploadedImage.src = "";
        }
    }



    function init() {
        camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1500 );
        camera.position.z = 200;

        controls = new THREE.TrackballControls( camera );

        console.log(camera.position);

        controls.rotateSpeed = 1.0 * 10;
        controls.zoomSpeed = 1.8 * 10;
        controls.panSpeed = 0.8 * 10;

        controls.noZoom = false;
        controls.noPan = false;

        controls.staticMoving = true;
        controls.dynamicDampingFactor = 0.3;

        controls.keys = [ 65, 83, 68 ];

        controls.addEventListener( 'change', render );


        // world
        scene = new THREE.Scene();

        var geometry = new THREE.CylinderGeometry( 0, 10, 30, 4, 1 );
        var material;

        // axes
        axes = new THREE.AxisHelper( 1000 );
        scene.add( axes );

        var loader = new THREE.TextureLoader();
        // URL of texture
        loader.load("boxtexture.jpg", function(texture){
            material = new THREE.MeshLambertMaterial({map: texture});

            geometry = new THREE.BoxGeometry( texture.image.width/10.0, texture.image.height/10.0,.0001 );
            var cube = new THREE.Mesh( geometry, material );

            cube.position.z = 0.1;
            scene.add( cube );

            removable_items.push(cube);

            render();
        });




        // lights
        light = new THREE.DirectionalLight( 0xffffff );
        light.position.set( 1, 1, 1 );
        scene.add( light );

        light = new THREE.DirectionalLight( 0xffffff );
        light.position.set( -1, -1, -1 );
        scene.add( light );

        light = new THREE.AmbientLight( 0xffffff );
        scene.add( light );


        // renderer
        renderer = new THREE.WebGLRenderer( { antialias: false } );
        //renderer.setClearColor( scene.fog.color );
        renderer.setClearColor( '#cccccc' );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );

        container = document.getElementById( 'container' );
        container.appendChild( renderer.domElement );

        stats = new Stats();
        container.appendChild( stats.dom );

        //

        window.addEventListener( 'resize', onWindowResize, false );
        //

        render();
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

        controls.handleResize();

        render();
    }

    function animate() {
        requestAnimationFrame( animate );
        controls.update();
    }

    function render() {
        renderer.render( scene, camera );
        stats.update();
    }


</script>

</body>
</html>